#version 430 core

layout(local_size_x = 64) in;

layout(std430, binding = 0) buffer VertexBuffer
{
    float data[];
};

layout(std430, binding = 1) buffer TempBuffer
{
    float tempData[];
};

uniform int uVertexCount;
uniform float uSmoothingFactor;

const int VERTEX_SIZE = 16;
const int POS_OFFSET = 0;
const int COLOR_RANGE_OFFSET = 8;

vec3 getPosition(uint idx)
{
    uint base = idx * VERTEX_SIZE;
    return vec3(data[base + POS_OFFSET], 
                data[base + POS_OFFSET + 1], 
                data[base + POS_OFFSET + 2]);
}

float getScalarValue(uint idx)
{
    uint base = idx * VERTEX_SIZE;
    return data[base + COLOR_RANGE_OFFSET];
}

void setScalarValue(uint idx, float value)
{
    uint base = idx * VERTEX_SIZE;
    data[base + COLOR_RANGE_OFFSET] = value;
}

void main()
{
    uint idx = gl_GlobalInvocationID.x;
    
    if (idx >= uVertexCount)
        return;
    
    vec3 currentPos = getPosition(idx);
    float currentValue = getScalarValue(idx);
    
    float sum = currentValue;
    int count = 1;
    
    const float EPSILON = 0.001;
    
    for (uint i = 0; i < uVertexCount; ++i)
    {
        if (i == idx)
            continue;
        
        vec3 otherPos = getPosition(i);
        float dist = distance(currentPos, otherPos);
        
        if (dist < EPSILON)
        {
            float otherValue = getScalarValue(i);
            sum += otherValue;
            count++;
        }
    }
    
    float avgValue = sum / float(count);
    float smoothedValue = mix(currentValue, avgValue, uSmoothingFactor);
    
    tempData[idx] = smoothedValue;
}
